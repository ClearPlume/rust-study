# 所有权和借用

## 没有内存回收的代码

```
// C 语言
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}
```

函数`foo`返回了一个`a`的引用，但`a`和`c`是局域变量，因此函数执行结束后将被回收。这会导致有一个指针指向不存在的值，`"xyz"`也无法被回收，除非程序终止。

## Rust 对栈与堆上数据的处理

### 栈

Rust 把基本类型的值存到栈上，涉及到变量赋值时直接复制值本身

### 堆

复杂类型的值会被存到堆上。当进行变量间赋值(`a = b`)时，Rust 会将b与值的连接断开并使其失效，然后将值的所有权交给a。这个动作被称之为所有权的**移动**，所有权移动后`a`将失效。

Rust **不会**自动进行堆上值的复制

## 定义

**所有权**: 描述了值与变量之间的关系，一个值`属于`一个变量，一个变量`拥有`一个值的`所有权`  
**借用**: 获取一个变量的引用，不涉及所有权的变更。引用有两种，`可变引用`和`不可变引用`。这里的可变性指的是“可否通过引用修改值”  
**悬垂引用**: 创建了一个值的引用，值被释放了但引用还在

## 规则

1. 一个值**有且只有**一个所有者
2. 值的所有者离开作用域时，值将被丢弃
3. 同一时刻，只能拥有一个可变引用**或者**任意多个不可变引用，**不可**同时拥有可变引用和不可变引用
4. 在函数参数中，若不通过的引用的方式接收值，则会发生所有权的传递。若需要在函数调用后再使用值，则需要函数再将值返回
5. 引用的作用域从定义时开始，到最后一次使用时结束(NLL, Non-Lexical Lifetimes)
